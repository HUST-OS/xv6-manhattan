# 内存映射
内存映射主要指`mmap`和`munmap`这两个系统调用，在实现这两个系统调用之前，我们首先建立了一个机制能够统一按不同的段管理一个用户进程中所有的虚拟空间。

## 段管理机制

在原本的 xv6 中，用户虚拟地址空间从 `0` 开始，所有段的地址范围都是相邻的，首先是从 ELF 中载入的部分，紧接着是栈，最后是一个可以向上扩展的堆空间。
在 Makefile 中，用户程序的编译规则是将包括代码节、数据节等在内的所有节放在一个段中，因此它们的权限都是可读可写可执行。
这种方式很不灵活，并且不能根据不同段的属性设置相应的权限，就会存在代码区域可被写，数据区域可以被执行等问题。

考虑到这个设计的不足以及新的功能需求，我们建立了用户进程的段管理机制。
这个机制通过一个链表`segments`记录用户进程中所有的段的信息，包括段类型、起始虚拟地址、保护标记、段长度。

关于段类型，综合考虑之后我们设置了如下枚举常量：`NONE`, `LOAD`, `TEXT`, `DATA`, `BSS`, `HEAP`, `MMAP`, `STACK`。

需要注意的是，这个链表是按照起始虚拟地址升序排列的，因而当需要新建一个段的时候，会从表头开始遍历，直至找到对应的地方将其插入。当然，在这个过程中会判断新插入的段与已存在的段是否存在地址交叉。

当启动一个用户进程的时候，内核就会按照可执行文件中的ELF头部中的信息加载这些段，并记录到segments链表中，并为页表设置相应权限。

这个机制增加了用户进程的虚拟地址空间管理的弹性，为内存管理带来了极大的便利。
用户空间分成了真正意义上的多个段，具有各自对应的页表权限。在原 xv6 实现中，只有堆栈可以向上扩展，而在引入段管理机制后，栈段、内存映射段也都有了可增长的基础。
段管理机制也为页表管理的一些方面提供了基础。由于我们引入了写时复制的克隆和堆的懒分配，缺页异常会时常发生。此时，在段管理链中查询引发缺页异常地址的所属段，
就可以判断造成缺页异常的原因，即确认这个地址是否落在合法的段内，是否为用户空间中未映射的非法空洞，这为缺页异常处理提供了依据。

## mmap系统调用
有了上述的段管理机制，我们最初的想法是直接在虚拟地址空间中找一片空闲区域用于`mmap`映射，并将这个段记录在`segments`链表中。现在就需要考虑内存布局的问题——映射至何处？经过考量，决定将`MMAP`内存映射区域置于用户栈的上方，即用户栈从`0x70000000`开始向低地址生长，`MMAP`内存映射区域从`0x70000000`开始向高地址生长。

由于共享机制的存在，我们还需要记录一个文件被映射的情况，那么在哪记录呢？文件描述符`fd`？’打开文件形成的`struct file`结构体？还是文件对应的`inode`？由于共享不只是局限于父子进程之间，因而我们只能选择放在文件对应的`inode`结构体中。

如何记录被映射的信息呢？首先需要考虑的是粒度的问题。在大多情况下，进程`A`与进程`B`共享的只会是其中的某几个页，所以决定按页来记录文件被映射的情况。同样，这里我们仍然选择使用链表来记录。为了方便后续的管理以及`munmap`实现，这个链表是按照在文件中的偏移地址升序排序。

那么共享是如何实现的呢？当进程`A`首次映射文件`f`中的某一个页面`p`，并且允许共享，那么内核将会在链表中插入一个结点记录映射的情况：偏移`offset`， 被映射到的物理地址`ph_addr`， 共享进程数`n_ref`。首次映射时`n_ref`被设置为1，物理地址`ph_addr`字段将被设置为对应的物理地址值。

在这之后如果进程`B`也要以共享的方式映射文件`f`中的页面`p`，内核将会在文件`f`对应的链表里面通过`offset`查找这个页是否被映射过，由于之前`A`已经映射过并且进程`A`允许共享，那么一定会找到，此时只需要将虚拟地址空间映射到对应的物理地址即可。

接下来只需要考虑不共享的情况。即使不允许共享，在进行`mmap`系统调用时仍然需要去对应的链表中查找，这是由于`MMAP`采用的是类似写回的机制，对于已经共享的映射页面，后续进程就应该能够看到最新的修改，所以就应该从已经映射的地方拷贝过来，而不是从文件本身拷贝过来。换句话说，如果以不共享的方式进行`mmap`系统调用，会首先分配物理页面、建立虚拟地址与物理页面的映射，然后在链表中查找，如果找到了就直接把找到的那片物理内存中的内容拷贝到新分配的物理页面中;如果没找到，那么就应该从文件中的对应位置拷贝过来。


需要指出的是，由于`inode`中是按照页面大小为粒度进行映射信息记录的，`mmap`如果接受的`len`长度超过一个页面，同样会将上述操作以页为单位重复执行。例如，如果`len = 8KB`那么上述描述的”查找链表、\[建立结点\]、\[分配物理页\]、建立映射、拷贝内容“过程就会重复执行2次。

## munmap系统调用
在设计了`mmap`机制之后，`munmap`机制的设计就相对容易了。如果是共享的页面，那么除了写回文件，还需要删除对应的`segments`结点、修改对应的`inode`结构体中相应的映射信息记录结点中的`n_ref--`，当`n_ref`减到0时释放对应的物理页，并删除该结点。如果是不共享的页面，那么直接将该页面写回文件，随后释放对应的虚拟地址空间和物理内存，然后删除对应的`segments`结点。

需要注意的是，如果只是`munmap`某一次`mmap`映射的内存中的一个页，那么不是删除`segments`结点，而是修改其偏移`offset`或长度`sz`，甚至有时需要增加`segments`结点。

如果用户进程未显式调用`munmap`就退出的话，内核在结束进程的时候会逐一释放所有的段，若通过`segments`结点检测到`MMAP`段，释放`MMAP`段的过程和显式进行`munmap`系统调用类似，但是区别在于并没有将用户对映射内存进行的修改写回文件。