# 内存映射
内存映射主要指`mmap`和`munmap`这两个系统调用，在实现这两个系统调用之前，我们首先建立了一个机制能够统一按不同的段管理一个用户进程中所有的虚拟空间。

## 段管理机制

在原本的 xv6 中，用户虚拟地址空间从 `0` 开始，所有段的地址范围都是相邻的，首先是从 ELF 中载入的部分，紧接着是栈，最后是一个可以向上扩展的堆空间。
在 Makefile 中，用户程序的编译规则是将包括代码节、数据节等在内的所有节放在一个段中，因此它们的权限都是可读可写可执行。
这种方式很不灵活，并且不能根据不同段的属性设置相应的权限，就会存在代码区域可被写，数据区域可以被执行等问题。

考虑到这个设计的不足以及新的功能需求，我们建立了用户进程的段管理机制。
这个机制通过一个链表`segments`记录用户进程中所有的段的信息，包括段类型、起始虚拟地址、保护标记、段长度。

关于段类型，综合考虑之后我们设置了如下枚举常量：`NONE`, `LOAD`, `TEXT`, `DATA`, `BSS`, `HEAP`, `MMAP`, `STACK`。

需要注意的是，这个链表是按照起始虚拟地址升序排列的，因而当需要新建一个段的时候，会从表头开始遍历，直至找到对应的地方将其插入。当然，在这个过程中会判断新插入的段与已存在的段是否存在地址交叉。

当启动一个用户进程的时候，内核就会按照可执行文件中的ELF头部中的信息加载这些段，并记录到segments链表中，并为页表设置相应权限。

这个机制增加了用户进程的虚拟地址空间管理的弹性，为内存管理带来了极大的便利。
用户空间分成了真正意义上的多个段，具有各自对应的页表权限。在原 xv6 实现中，只有堆栈可以向上扩展，而在引入段管理机制后，栈段、内存映射段也都有了可增长的基础。
段管理机制也为页表管理的一些方面提供了基础。由于我们引入了写时复制的克隆和堆的懒分配，缺页异常会时常发生。此时，在段管理链中查询引发缺页异常地址的所属段，
就可以判断造成缺页异常的原因，即确认这个地址是否落在合法的段内，是否为用户空间中未映射的非法空洞，这为缺页异常处理提供了依据。

## `mmap` 系统调用
有了上述的段管理机制，我们最初的想法是直接在虚拟地址空间中找一片空闲区域用于`mmap`映射，并将这个段记录在`segments`链表中。现在就需要考虑内存布局的问题——映射至何处？经过考量，决定将`MMAP`内存映射区域置于用户栈的上方，即用户栈从`0x70000000`开始向低地址生长，`MMAP`内存映射区域从`0x70000000`开始向高地址生长。

由于共享机制的存在，我们还需要记录一个文件被映射的情况，那么在哪记录呢？文件描述符`fd`？’打开文件形成的`struct file`结构体？还是文件对应的`inode`？由于共享不只是局限于父子进程之间，因而我们只能选择放在文件对应的`inode`结构体中。

如何记录被映射的信息呢？首先需要考虑的是粒度的问题。在大多情况下，进程`A`与进程`B`共享的只会是其中的某几个页，所以决定按页来记录文件被映射的情况。同样，这里我们仍然选择使用链表来记录。为了方便后续的管理以及`munmap`实现，这个链表是按照在文件中的偏移地址升序排序。

那么共享是如何实现的呢？当进程`A`首次映射文件`f`中的某一个页面`p`，并且允许共享，那么内核将会在链表中插入一个结点记录映射的情况：偏移`offset`， 被映射到的物理地址`ph_addr`， 共享进程数`n_ref`。首次映射时`n_ref`被设置为1，物理地址`ph_addr`字段将被设置为对应的物理地址值。

在这之后如果进程`B`也要以共享的方式映射文件`f`中的页面`p`，内核将会在文件`f`对应的链表里面通过`offset`查找这个页是否被映射过，由于之前`A`已经映射过并且进程`A`允许共享，那么一定会找到，此时只需要将虚拟地址空间映射到对应的物理地址即可。

接下来只需要考虑不共享的情况。即使不允许共享，在进行`mmap`系统调用时仍然需要去对应的链表中查找，这是由于`MMAP`采用的是类似写回的机制，对于已经共享的映射页面，后续进程就应该能够看到最新的修改，所以就应该从已经映射的地方拷贝过来，而不是从文件本身拷贝过来。换句话说，如果以不共享的方式进行`mmap`系统调用，会首先分配物理页面、建立虚拟地址与物理页面的映射，然后在链表中查找，如果找到了就直接把找到的那片物理内存中的内容拷贝到新分配的物理页面中;如果没找到，那么就应该从文件中的对应位置拷贝过来。


需要指出的是，由于`inode`中是按照页面大小为粒度进行映射信息记录的，`mmap`如果接受的`len`长度超过一个页面，同样会将上述操作以页为单位重复执行。例如，如果`len = 8KB`那么上述描述的”查找链表、\[建立结点\]、\[分配物理页\]、建立映射、拷贝内容“过程就会重复执行2次。

**更新**：  
现阶段，我们为 `mmap` 系统调用扩充了一些功能，除了原先支持的文件私有/共享映射，还支持了匿名映射和固定映射（同样支持私有/共享），
但固定映射映射的实现仍然存在一些问题。根据 POSIX 标准，使用固定映射时，若所指定的合法范围内存在映射，则会把这些映射摘除。
在我们目前的实现中，如果在固定映射的操作过程中出现内存分配失败等问题，那么原有的映射将无法恢复，这是处于简单实现考虑。对于完整实现，
我初步考虑这个问题可以有下列解决方案：

1. 预先保存被取消映射的页面，若后续分配新页面失败，则将原有页面重新映射回去；
2. 首先分配新的页面，若成功，再将它们加入到页表映射中，并将原有映射删除；
3. 采用懒惰分配方式，只对新页面所需的文件信息做记录，而不是直接分配新页，待访问时再申请载入。

我认为以上方式各有优缺点。前两种方案的处理机制类似，其问题在于如何保存各个物理页以及对应的虚拟地址，而优点是可以保证成功返回时，
页面一定存在，失败时则可以保留原有页面；后一种方案本质上是将问题推后处理，优点很明显，缺点则是，当用户程序真正使用到了相关页面，
引起缺页异常时，若无法分配页面，则只能将进程杀死。总体来看，第三种方案应该是最好的，至于缺页时无法分配的问题，可以引入 swap 机制，
或者将进程挂起直至内存可用（显然有资源有限导致死锁的可能），而这些就是新的故事了。


## `munmap` 系统调用
在设计了`mmap`机制之后，`munmap`机制的设计就相对容易了。如果是共享的页面，那么除了写回文件，还需要删除对应的`segments`结点、修改对应的`inode`结构体中相应的映射信息记录结点中的`n_ref--`，当`n_ref`减到0时释放对应的物理页，并删除该结点。如果是不共享的页面，那么直接将该页面写回文件，随后释放对应的虚拟地址空间和物理内存，然后删除对应的`segments`结点。

需要注意的是，如果只是`munmap`某一次`mmap`映射的内存中的一个页，那么不是删除`segments`结点，而是修改其偏移`offset`或长度`sz`，甚至有时需要增加`segments`结点。

如果用户进程未显式调用`munmap`就退出的话，内核在结束进程的时候会逐一释放所有的段，若通过`segments`结点检测到`MMAP`段，释放`MMAP`段的过程和显式进行`munmap`系统调用类似，但是区别在于并没有将用户对映射内存进行的修改写回文件。

**更新**：  
我们发现，真正符合标准的 `munmap` 调用比我们设想的要复杂。实际上 `munmap` 和 `mmap` 中的固定映射所取消的映射可以是任意段映射，
也就是说，`munmap` 可以取消 `mmap` 映射之外的地址映射。我在 Linux 上进行了一些小实验，发现即使传入的任意的虚拟地址和长度，
也可以成功返回。这也意味着，在所要取消的映射范围内，确实存在的地址映射片段可以不连续，这也就要求我们的实现中可以分割任意 `segment` 
结点。这也是一个稍微有些棘手的工作，在该情境下，一个 `segment` 可能被完全释放，也可能前一部分或后一部分被释放，当然了，
还可能在中间挖一个空洞，从而分裂成两个 `segment`。对于 `mmap` 的固定映射也同理。此外，如果任意段类型的 `segment` 都可以分裂，
显然会带来问题，原先的一些代码就需要修改。例如，堆对应的 `segment` 原本只有一个，若被分裂成两段，如何得到正确的堆顶？
如果堆被彻底取消映射，那么再次调用 `brk` 时该如何处理？看来还是有很多问题需要解决啊。

顺带一提，在 lua 应用的支持工作中，我们发现它会首先通过 `brk` 调用获取、扩展堆段的空间，随后，对堆底部分施加了一个固定、匿名的 
`mmap` 映射。尚不明确这是运行时库的工作还是 lua 编写者的本意，但这说明了原有的非 `mmap` 段映射是可以被覆盖、删除的。此外我们还注意到，
这个映射调用中指定的权限是 `NONE`，即不可读、不可写及不可执行，可以推测其起到保护页的作用，防止越界访问等问题。其实，要实现保护页，
可以使用接下来提到的 `mprotect` 系统调用。

## `mprotect` 系统调用
该系统调用可以为指定的虚拟地址范围设置权限，即是否可读、可写、可执行。初步设想，这应该是个实现起来很简单的系统调用，改改页表就好嘛！
然而，代码写到一半时，我才发现事情没有这么简单……我们给自己挖了个坑，确切地说是两个：写时复制和懒惰堆分配。坑是自己挖的，填也得自己填。

对于写时复制，如果进程克隆时某个页面没有写权限，那么这个页面将会被父子进程共用。在该情况下，如果其中一个进程突然请求写权限，
那么就要考虑是否需要复制页面了。对于懒惰堆分配，需要修改权限的页面可能并未实际分配，甚至相关的页表页还没有分配。此时该如何记录权限呢？
可以有两种方案：
1. 在对应的 `segment` 上做标记，真正分配页面时按记录值进行，但这涉及 `segment` 分裂问题（因为相邻页面可能权限不一致），不好处理；
2. 直接分配页表，先设置好权限，但不分配页（页表项中的 V 标记仍为 0），真正分配页面时以页表项上已有记录为准，而非依据 `segment` 的记录。

我们选择了方案 2，一来是避免繁琐的 `segment` 分裂问题，二来则是因为 `segment` 的权限记录值实际上没有控制作用（页表项上的值才有），
因为如果用户程序违背了页面权限，异常会产生，内核根本不需要通过 `segment` 来判断。因此可以直接在页表上设置权限位，当为页表项建立映射时，
若页表项上已有权限位，则以之位准。这个标记除了读、写、执行，还需要一个额外的 U 标记（用户位），这是因为 `mprotect` 可以支持 `NONE` 
类型的权限，此时相应的页表项权限位都是 0，就无法标识页表项状态。但无论如何，U 权限位最终都会被置上，可以用它作为标记。

