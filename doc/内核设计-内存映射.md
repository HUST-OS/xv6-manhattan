# 内存映射
内存映射主要指`mmap`和`munmap`这两个系统调用，在实现这两个系统调用之前，我们首先建立了一个机制能够统一按不同的段管理一个用户进程中所有的虚拟空间。

## 段管理机制
这个机制通过一个链表`segments`记录用户进程中所有的段的信息，包括段类型、起始虚拟地址、保护标记、段长度。

关于段类型，综合考虑之后我们设置了如下枚举常量：`NONE`, `LOAD`, `TEXT`, `DATA`, `BSS`, `HEAP`, `MMAP`, `STACK`。

需要注意的是，这个链表是按照起始虚拟地址升序排列的，因而当需要新建一个段的时候，会从表头开始遍历，直至找到对应的地方将其插入。当然，在这个过程中会判断新插入的段与已存在的段是否存在地址交叉。

当启动一个用户进程的时候，内核就会按照可执行文件中的ELF头部中的信息加载这些段，并记录到segments链表中。

这个机制增加了用户进程的虚拟地址空间管理的弹性，为内存管理带来了极大的便利。

## mmap系统调用
有了上述的段管理机制，我们最初的想法是直接在虚拟地址空间中找一片空闲区域用于`mmap`映射，并将这个段记录在`segments`链表中。现在就需要考虑内存布局的问题——映射至何处？经过考量，决定将`MMAP`内存映射区域置于用户栈的上方，即用户栈从`0x70000000`开始向低地址生长，`MMAP`内存映射区域从`0x70000000`开始向高地址生长。

由于共享机制的存在，我们还需要记录一个文件被映射的情况，那么在哪记录呢？文件描述符`fd`？’打开文件形成的`struct file`结构体？还是文件对应的`inode`？由于共享不只是局限于父子进程之间，因而我们只能选择放在文件对应的`inode`结构体中。

如何记录被映射的信息呢？首先需要考虑的是粒度的问题。在大多情况下，进程`A`与进程`B`共享的只会是其中的某几个页，所以决定按页来记录文件被映射的情况。同样，这里我们仍然选择使用链表来记录。考虑到局部性原理，当需要新增加新的映射页面时直接在链表头插入新的结点。

那么共享是如何实现的呢？当进程`A`首次映射文件`f`中的某一个页面`p`，并且允许共享，那么内核将会在链表中插入一个结点记录映射的情况：偏移`offset`， 被映射到的物理地址`ph_addr`， 共享进程数`n_ref`。首次映射时`n_ref`被设置为1，物理地址`ph_addr`将被设置为`NULL`值。此时如果进程`B`也要以共享的方式映射文件`f`中的页面`p`，内核将会在文件`f`对应的链表里面通过`offset`查找这个页是否被映射过，找到后将返回链表中的这个结点（同时将`n_ref++`。也就是说，如果一个进程希望以共享的方式映射一个页面，那么无论这个页面是否被映射过，`mmap`经过查找后都会拿到一个结点，如果这个结点中`ph_addr`字段为空，那么mmap会分配一个新的物理页，并将之前建立的虚拟地址空间映射到个新分配的物理页，同时也会将这个物理页的起始地址写回到拿到的结点的`ph_addr`字段;如果这个结点中`ph_addr`字段本就不为空，那么直接将虚拟地址空间映射到`ph_addr`所指向的物理界面即可。

那如果进程`B`不希望以共享的方式映射呢？内核同样会去链表中查找，如果找到了，也会返回那个结点，但是不会进行`n_ref++`，如果没找到，便会返回`NULL`看空值，也不会建立新的结点。为什么要这么做呢？由于`MMAP`采用的是类似写回的机制，对于已经共享的映射页面，后续进程就应该能够看到最新的修改，所以就应该从已经映射的地方拷贝过来，而不是从文件本身拷贝过来。

需要指出的是，由于`inode`中是按照页面大小为粒度进行映射信息记录的，`mmap`如果接受的`len`长度超过一个页面，同样会将上述操作以页为单位重复执行。例如，如果`len = 8KB`那么上述描述的”查找链表、\[建立结点\]、\[分配物理页\]、建立映射、拷贝内容“过程就会重复执行2次。