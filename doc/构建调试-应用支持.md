# **应用支持**
文档编写：AtomHeartCoder
<br>
<br>

虽然 xv6-k210 已经可以支持用户 ELF 程序的运行，但这些程序只是不带标准库进行编译的简单程序。现阶段，若要支持 Linux 
上运行的程序（如 busybox），还需要进行额外的支持。目前 xv6-k210 暂不支持动态库的链接，只支持静态编译的程序。因此，
若要支持 Linux 上运行的 busybox 程序，需要从两方面进行考虑，一是系统调用接口与返回值的约定，二是用户程序启动时，
内核为程序准备的栈的内容。本文大致记录了调试支持 busybox 程序的过程。

# Busybox 的支持

## 1. 尝试启动
我们使用的是静态编译的 busybox，既然是静态编译，不需要依赖动态库支持，或许可以直接运行起来？我们预期 busybox 
会请求一些尚未实现的系统调用，然后因为我们的内核尚未实现相关接口而报错退出。然而，busybox 直接触发了访存异常，
被内核强制终止了。通过内核的系统调用跟踪发现，busybox 在 `execve` 和两次 `brk` 系统调用后，直接触发了缺页异常！
访问的地址为 0。系统调用是支持的，但为何程序会引发异常呢？

## 2. 接口规范
为找到答案，首先需要知道正常的运行过程是怎样的。我们在 Debian 镜像上通过 `strace` 命令追踪运行了 busybox，
观察到一开始几个系统调用是相同的，不同的是 `brk` 的返回值。在之前阅读的文档描述中，`brk` 调用会修改进程的堆段，
成功则返回 0，失败则返回 -1。但是在 Debian 上，`brk` 返回的是修改后的堆栈地址。也正是这时我们才注意到，
若给 `brk` 传递的参数是 0，该调用也会返回一个非零值，这与我们所实现的版本不同。通过查阅资料才得知，很多文档（包括 man）
中描述的“系统调用”都是封装好的库函数，并非直接的系统调用。Linux man 手册中即有库函数的描述，也有系统调用的描述，
需要注意遵循 POSIX 的约定标准。随后，我们调整了部分与标准不同的系统调用，在后续工作中，也开始关注库函数与直接调用的差异。

## 3. 硬核调试
这是第一个被找到的问题，但并未能解决访存异常的问题。追踪系统调用已经不能提供更多用户态的信息了。在各种调试方法中，
由于目标程序已编译好，不能使用打印追踪法，那么唯一的方法就是使用 gdb 了。我们从镜像中获取的 busybox 中没有调试信息，
只能对着汇编指令调试，十分困难。我们尝试自行编译带调试信息的 busybox，但一直编译失败。不过有一次居然编译成功了！
可惜我很快意识到用错了工具链……但至少可以作为参照。然而，我们发现引起访存异常的指令所在的函数没有源代码信息，
这说明它是某个库函数，并不能提供什么语义信息。

最后，我们只能直接对着汇编指令进行调试工作了。我们在 Debian 上直接使用 gdb 调试 busybox，在本机上用 riscv 的 gdb 
调试 qemu 中的内核，一条一条指令对比执行。这是个痛苦的过程，但好在我们发现了问题。正常运行的程序会从一段地址中读取信息，
而在我们的内核上则很快跳过了这一段指令。经过一些记录和计算，我们发现这段地址是在栈上，恍然大悟也。

用户栈是 `execve` 系统调用实现的，在我们已经实现的版本中，已经按照 Linux 的约定标准来做了，包括参数数量、参数指针列表、
环境变量指针列表等。是什么导致了问题的发生？原来，除了这些传统的约定，还有一个叫辅助向量的二元组序列，存放了用户 ID、
ELF 文件信息、内存单元大小等信息，用键值形式表示。但这些信息实在是太多了，难以完全提供。所幸的是，进一步调试后，
我们发现程序只需要其中一部分，并且内核可以较方便地提供，主要包括：
+ 内存单元（页）大小
+ ELF 文件的 program header 的虚拟地址（但有的程序并不一定把程序段的信息包含在载入段内）
+ program header 的数量
+ 用户 ID 和用户组 ID（xv6-k210 暂不支持多用户，设置为 0，与 Linux 中的 root 等效）
+ secure（设为 0 即可）
+ 指向一个 16 字节随机数的地址
+ 结束标记元组

在解决这个问题后，busybox 终于可以较为正常地启动了！当然还是因为缺少系统调用而报错停止，但至少不会异常退出了。

经过这一番折腾后，我们做了一些总结。程序之所以不能正常运行，是因为内核没有满足程序编译依赖的标准库的启动运行时环境，
这实际上与 busybox 无关。但是，所缺少的部分叫做辅助变量，既名为辅助，意味着它不应当是运行的强依赖条件。
如果启动运行时的代码必须依赖这些辅助变量，那么程序就可能有较强的平台依赖性，当然这是另外一番讨论了。实际上，Linux 
对辅助向量的设置要复杂很多，还使用了随机栈偏移机制，让我不禁感叹 Linux 的复杂与强大。

## 4. 异常指令
在实现一些系统调用，推进 busybox 的运行后，我们遇到了另一个问题——非法指令。Busybox 中的一些指令会引起异常，引起 panic，
但这不是因为特权级的问题，而是浮点指令不支持。这个问题只在 qemu 上出现，在 k210 上则没有。这有些令人诧异，按理来说，
qemu 支持的指令集版本相比 k210 的 1.9.1 版本要新一些，支持性应该更好。我们只能怀疑是 qemu 的问题，因此我们没有深究，
而是选择将非法指令跳过。这么做也需要有充足的理由：我们所定位到非法指令出现在库函数的一个浮点寄存器保存现场的片段中，
而且此时还未进入主函数，对主要程序逻辑的影响有限。

我想尝试配置 qemu 支持的 RISC-V 指令集，但无果，qemu 似乎只能通过 -cpu 参数来指定支持的硬件版本。有意思的是，
如果我选择 qemu 的 RISC-V 1.9.1 指令集 cpu，其仍然能正常运行 `sfence.vma` 等新版本指令并支持 `stap` 寄存器的新格式，
而且 RustSBI-qemu 不会像 k210 版本处理这些异常。

PS: 我所使用的 qemu 是 4.2.1 版

# lua 的支持
在支持 busybox 后，lua 的支持工作就简单了许多，只需要实现相关的系统调用即可。这里就不做单独的介绍了，详情请阅读其他文档。