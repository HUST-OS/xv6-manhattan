# 浮点指令在 QEMU 下异常的解决
文档编写：AtomHeartCoder

在前一阶段，我们就已经发现用户程序中的浮点指令有时会导致非法指令异常，这一现象只出现在 qemu 下，
在 k210 上没有出现问题，因此我们便暂时将其搁置了。但在该阶段，浮点操作对于用户程序而言是必须的，
我们必须解决这一问题。

## 浮点异常
我们一般说的浮点运算异常，是指浮点数运算过程中的结果异常，例如精度不足、上溢、下溢或除以零等，
应当不至于引发特权态语境下的异常，更何况是非法指令异常。更令人难以理解的是，出问题的是 qemu，
而不是指令集较旧的 k210。在网络上搜索这一情况，没有任何结果，看来想快速解决问题是不可能的了，
只能老老实实读文档。

我首先查阅了《RISC-V手册——一本开源指令集的指南》一书，里面只提到了通常意义下的浮点运算异常。
在支持浮点指令扩展的 RISC-V 机器中，有一个浮点状态与控制寄存器 `fcsr`，其低 5 位保存了异常种类，
从第 4 位到第 0 位分别为非法操作、除以零、上溢、下溢和不精确。此外，第 5 ~ 7 位为舍入模式位，
有向偶舍入(`000`)、向零舍入(`001`)、向下舍入(`010`)、向上舍入(`011`)以及向最大值舍入(`100`)。
但是我没有在书中找到异常相关的内容。我尝试着在 qemu 中打印 `fcsr` 的内容，其舍入模式为 `000`,
产生过的浮点异常为不精确，此时并未引发非法指令异常。

在 busybox 的一个代码片段中，我观察到有点浮点指令不会引发异常，且其为压缩指令，而非压缩指令则会。
片段如下：
```
指令字      汇编语句
3920        fld fs0,112(a0) <- 压缩指令无异常
3d24        fld fs1,120(a0) <- 压缩指令无异常
08053907    fld fs2,128(a0) <- 引发非法指令异常
08853987    fld fs3,136(a0)
```

## 浮点指令导致的异常
随后，我在一篇介绍 RISC-V 浮点扩展的博客中学习到如下知识。浮点指令中的第 12 ~ 14 位为舍入模式，
即该指令可以指定具体的舍入模式，特别地，指令中的这个字段可以为 `111`，表示使用动态舍入模式，
也就是根据 `fcsr` 寄存器中设定的舍入模式进行运算，此时，如果 `fcsr` 寄存器中的舍入模式为非法值，
则会引发指令异常。我茅塞顿开。我还猜想，压缩指令不出问题可能是因为其舍入模式的字段被压缩掉了，
因为浮点存取指令并不涉及浮点运算，可以被忽略。可我又突然想到，之前打印 `fcsr` 中的值是合法的呀！
其值是 `000`，即向偶数舍入，这就很奇怪了。无奈之下，只能硬啃英文版的官方手册了。让人失望的是，
我也没有在相关的 F 扩展和 D 扩展的章节中找到答案。

## RISC-V 中的浮点单元管理
就在近乎绝望之际，我突然想到，之前使用的 Debian 镜像也是跑在 qemu 下的，但却可以正常运行呀！
Linux 是怎么处理的呢？于是我尝试在 Linux 中寻找答案。在 Linux 的 arch/riscv/kernel/entry.S 中，
一个代码片段吸引了我的注意：
```
/*
 * Disable user-mode memory access as it should only be set in the
 * actual user copy routines.
 *
 * Disable the FPU to detect illegal usage of floating point in kernel
 * space.
 */
li t0, SR_SUM | SR_FS

REG_L s0, TASK_TI_USER_SP(tp)
csrrc s1, CSR_STATUS, t0
```
原来 `sstatus` 寄存器中，也有浮点单元相关的控制位！我连忙查阅特权态相关的章节，终于找到了答案。
在 `mstatus` 寄存器中（对于 S 态下的内核，则是 `sstatus`），第 13 ~ 14 位（`fs`）为浮点状态位，
有四种状态，分别是 `off(00)`、`init(01)`、`clean(10)` 和 `dirty(11)`。其中，`off` 表示关闭，
即浮点单元不可用，这也正是 qemu 下出现异常的原因，因为我们未对其进行初始化！将 `sstatus.fs` 
设置，浮点单元就可以在 qemu 下正常使用了。

那么为什么 k210 下不需要设置呢？通过打印并修改 k210 中的 `sstatus.fs` 位，我发现无论怎么设置，
它总为 `11`，我推测这是被硬件强制设定的。关于这个字段，它主要用于辅助 S 态软件的上下文保存工作。
内核可将该字段的值设为 `10`，即 `clean`，若后续运行中浮点单元被使用，则硬件会自动将其设置为 `11`，
表示浮点寄存器是脏的（即与上一次设为 `10` 时的值不同），这就提示内核需要保存浮点相关的寄存器现场，
否则可以不保存。保存后，内核会重新将其设置为 `10`。这就减小了上下文切换的开销，可惜的是，k210 
的这个字段被硬置了，没法作为参考。

在我们的实现中，内核并不使用浮点单元，不会破坏浮点寄存器现场。也就是说，当 U 态发生内陷（trap）时，
可以不保存浮点寄存器，而可以只在发生进程切换的前后才进行保存与恢复，减少不必要的开销。

<br>

## 插曲
在将代码上传至测评平台进行测试时，我们发现评测平台的编译器并不支持浮点指令的汇编，这导致系统中用于保存
浮点上下文的汇编代码`kernel/trap/fcntxt.S`无法通过编译。而为了保证系统的正确性，我们又必须要对这些
上下文加以保存。为了解决这一问题，联想到initcode使用二进制数据的方式储存程序，我们将fcntxt.S中的代码
经过编译的二进制代码作为数组保存在了trap.c中，并链接到`.rodata`段中。这样，在保存上下文时，只要使程序
能够跳转到数组的起始地址，就可以运行数组中的代码。

当然，这一方法并不优雅，也不安全，仅作为本次比赛的权宜之计使用，我想并不具有太多的参考价值。

# 参考资料

+ [《RISC-V手册——一本开源指令集的指南》](http://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf)
+ [RISC-V ISA 学习笔记（3） 单精度浮点标准扩展 “F” v2.0](https://blog.csdn.net/New_Horizon_/article/details/90726544)
+ [*The RISC-V Instruction Set Manual Volume I: Unprivileged ISA*](https://github.com/riscv/riscv-isa-manual/)
+ [linux-5.12.4](https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/)
+ [*The RISC-V Instruction Set Manual Volume II: Privileged Architecture*](https://github.com/riscv/riscv-isa-manual/)
